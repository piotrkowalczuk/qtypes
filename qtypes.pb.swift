// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: qtypes.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Qtypes_QueryType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case null // = 0
  case equal // = 1
  case greater // = 2
  case greaterEqual // = 3
  case less // = 4
  case lessEqual // = 5
  case `in` // = 6
  case between // = 7
  case hasPrefix // = 8
  case hasSuffix // = 9
  case substring // = 10
  case pattern // = 11
  case minLength // = 12
  case maxLength // = 13
  case overlap // = 14
  case contains // = 15
  case isContainedBy // = 16
  case hasElement // = 17
  case hasAnyElement // = 18
  case hasAllElements // = 19
  case UNRECOGNIZED(Int)

  public init() {
    self = .null
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .null
    case 1: self = .equal
    case 2: self = .greater
    case 3: self = .greaterEqual
    case 4: self = .less
    case 5: self = .lessEqual
    case 6: self = .in
    case 7: self = .between
    case 8: self = .hasPrefix
    case 9: self = .hasSuffix
    case 10: self = .substring
    case 11: self = .pattern
    case 12: self = .minLength
    case 13: self = .maxLength
    case 14: self = .overlap
    case 15: self = .contains
    case 16: self = .isContainedBy
    case 17: self = .hasElement
    case 18: self = .hasAnyElement
    case 19: self = .hasAllElements
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .null: return 0
    case .equal: return 1
    case .greater: return 2
    case .greaterEqual: return 3
    case .less: return 4
    case .lessEqual: return 5
    case .in: return 6
    case .between: return 7
    case .hasPrefix: return 8
    case .hasSuffix: return 9
    case .substring: return 10
    case .pattern: return 11
    case .minLength: return 12
    case .maxLength: return 13
    case .overlap: return 14
    case .contains: return 15
    case .isContainedBy: return 16
    case .hasElement: return 17
    case .hasAnyElement: return 18
    case .hasAllElements: return 19
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Qtypes_QueryType] = [
    .null,
    .equal,
    .greater,
    .greaterEqual,
    .less,
    .lessEqual,
    .in,
    .between,
    .hasPrefix,
    .hasSuffix,
    .substring,
    .pattern,
    .minLength,
    .maxLength,
    .overlap,
    .contains,
    .isContainedBy,
    .hasElement,
    .hasAnyElement,
    .hasAllElements,
  ]

}

/// String ...
public struct Qtypes_String: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var values: [String] = []

  public var valid: Bool = false

  public var negation: Bool = false

  public var type: Qtypes_QueryType = .null

  public var insensitive: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Int64 ...
public struct Qtypes_Int64: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var values: [Int64] = []

  public var valid: Bool = false

  public var negation: Bool = false

  public var type: Qtypes_QueryType = .null

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Uint64 ...
public struct Qtypes_Uint64: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var values: [UInt64] = []

  public var valid: Bool = false

  public var negation: Bool = false

  public var type: Qtypes_QueryType = .null

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Float64 ...
public struct Qtypes_Float64: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var values: [Double] = []

  public var valid: Bool = false

  public var negation: Bool = false

  public var type: Qtypes_QueryType = .null

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Timestamp ...
public struct Qtypes_Timestamp: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var values: [SwiftProtobuf.Google_Protobuf_Timestamp] = []

  public var valid: Bool = false

  public var negation: Bool = false

  public var type: Qtypes_QueryType = .null

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "qtypes"

extension Qtypes_QueryType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "EQUAL"),
    2: .same(proto: "GREATER"),
    3: .same(proto: "GREATER_EQUAL"),
    4: .same(proto: "LESS"),
    5: .same(proto: "LESS_EQUAL"),
    6: .same(proto: "IN"),
    7: .same(proto: "BETWEEN"),
    8: .same(proto: "HAS_PREFIX"),
    9: .same(proto: "HAS_SUFFIX"),
    10: .same(proto: "SUBSTRING"),
    11: .same(proto: "PATTERN"),
    12: .same(proto: "MIN_LENGTH"),
    13: .same(proto: "MAX_LENGTH"),
    14: .same(proto: "OVERLAP"),
    15: .same(proto: "CONTAINS"),
    16: .same(proto: "IS_CONTAINED_BY"),
    17: .same(proto: "HAS_ELEMENT"),
    18: .same(proto: "HAS_ANY_ELEMENT"),
    19: .same(proto: "HAS_ALL_ELEMENTS"),
  ]
}

extension Qtypes_String: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".String"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
    2: .same(proto: "valid"),
    3: .same(proto: "negation"),
    4: .same(proto: "type"),
    5: .same(proto: "insensitive"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.values) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.valid) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.negation) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.insensitive) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitRepeatedStringField(value: self.values, fieldNumber: 1)
    }
    if self.valid != false {
      try visitor.visitSingularBoolField(value: self.valid, fieldNumber: 2)
    }
    if self.negation != false {
      try visitor.visitSingularBoolField(value: self.negation, fieldNumber: 3)
    }
    if self.type != .null {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 4)
    }
    if self.insensitive != false {
      try visitor.visitSingularBoolField(value: self.insensitive, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qtypes_String, rhs: Qtypes_String) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.valid != rhs.valid {return false}
    if lhs.negation != rhs.negation {return false}
    if lhs.type != rhs.type {return false}
    if lhs.insensitive != rhs.insensitive {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qtypes_Int64: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Int64"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
    2: .same(proto: "valid"),
    3: .same(proto: "negation"),
    4: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.values) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.valid) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.negation) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitPackedInt64Field(value: self.values, fieldNumber: 1)
    }
    if self.valid != false {
      try visitor.visitSingularBoolField(value: self.valid, fieldNumber: 2)
    }
    if self.negation != false {
      try visitor.visitSingularBoolField(value: self.negation, fieldNumber: 3)
    }
    if self.type != .null {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qtypes_Int64, rhs: Qtypes_Int64) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.valid != rhs.valid {return false}
    if lhs.negation != rhs.negation {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qtypes_Uint64: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Uint64"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
    2: .same(proto: "valid"),
    3: .same(proto: "negation"),
    4: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.values) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.valid) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.negation) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.values, fieldNumber: 1)
    }
    if self.valid != false {
      try visitor.visitSingularBoolField(value: self.valid, fieldNumber: 2)
    }
    if self.negation != false {
      try visitor.visitSingularBoolField(value: self.negation, fieldNumber: 3)
    }
    if self.type != .null {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qtypes_Uint64, rhs: Qtypes_Uint64) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.valid != rhs.valid {return false}
    if lhs.negation != rhs.negation {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qtypes_Float64: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Float64"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
    2: .same(proto: "valid"),
    3: .same(proto: "negation"),
    4: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedDoubleField(value: &self.values) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.valid) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.negation) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitPackedDoubleField(value: self.values, fieldNumber: 1)
    }
    if self.valid != false {
      try visitor.visitSingularBoolField(value: self.valid, fieldNumber: 2)
    }
    if self.negation != false {
      try visitor.visitSingularBoolField(value: self.negation, fieldNumber: 3)
    }
    if self.type != .null {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qtypes_Float64, rhs: Qtypes_Float64) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.valid != rhs.valid {return false}
    if lhs.negation != rhs.negation {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qtypes_Timestamp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Timestamp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
    2: .same(proto: "valid"),
    3: .same(proto: "negation"),
    4: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.values) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.valid) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.negation) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.values, fieldNumber: 1)
    }
    if self.valid != false {
      try visitor.visitSingularBoolField(value: self.valid, fieldNumber: 2)
    }
    if self.negation != false {
      try visitor.visitSingularBoolField(value: self.negation, fieldNumber: 3)
    }
    if self.type != .null {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qtypes_Timestamp, rhs: Qtypes_Timestamp) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.valid != rhs.valid {return false}
    if lhs.negation != rhs.negation {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
